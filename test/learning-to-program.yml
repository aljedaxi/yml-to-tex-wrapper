intro:
  Thus, the goals of a programming system should be:
    - to support and encourage powerful ways of thinking
    - to enable programmers to see and understand the execution of their programs
  We change programming. We turn it into something that's understandable by people:
    - what is the actual goal of what we're doing? What behaviors are we trying to enable?
    - are we trying to create professional programmers? Or are we trying to create people who aren't afraid of the command line?
    - once we understand what we're really trying to do, it's then that we can create our curriculum.
    - it is worth considering that most of the people we're trying to teach to program aren't good at it, will never be good at it, and don't ever want to be good at it. most people don't want to---and probably can't---be the epic hacker we want to mould them into to.
    - so what's the point? 
contents:
  environment:
    read the vocabulary:
      - would we want a system that allows the user to mouse over a given keyword a get an explanation?
      - to mouse over a variable and see everywhere it's defined?
      - - you can jig this together by abusing your search feature
        - you can do that in vi with `*'
      - do you remember when programmers were in tears about how their students wouldn't be doing `real programming' if they wrote assembly instead of machine code?
      - - we must overcome our attachment to the machine.
        - it's interesting to think about when we've progressed far enough that we no longer have to teach those old concepts.
        - - when have we reached the point where even teaching loops is pointless?
    follow the flow:
      - something like a debugger but less annoying
      - more visual? 
      - there's a reason i don't use debuggers
    see the state:
      - debuggers?
    create by reacting, create by abstracting:
      - this is the UNIX, bottom up philosophy to program design
      - - maligned by the fools in the universities, but brought back by agile development
  language:
    identity and metaphor:
      - is this a question of good variable names?
      - is this a question of starting with OOP?
      - is this a question of project based, actually useful programming techniques?
      - having been thinking for the past ten minutes, i think this is the best way, at least for teens.
      - - "i learned to program through the command line: automating my writing projects. While other people never understood how this knowledge could do anything for them, i viewed programming as something invaluable to my everyday existence."
        - it's the ability to use the command line that gave me this freedom.
    decomposition:
      - how do i actually put a program together?
      - it begins to answer the question of where to start
      - i guess this is why we need to teach functions early
    composition:
      - recomposition implies that you start at x, break it into [y], and end with x. what if you start with [y]? 
      - - it privileges a top down design philosophy that i don't think is useful here.
      - how do i actually put a program together?
      - it begins to answer the question of where to start
    readability:
      - under no circumstances should we use haskell
read the vocabulary:
  make meaning transparent:
    - yeah i'm also totally against the guess and check method
follow the flow:
  - i guess it's worth noting that this section is proposing a harsh imperative style? I'd imagine that declarative programming would be easier to understand, not having to get into the details of the implementation.
  - - it'd be interesting to contrast the two; to try to teach R without using a single loop.
show the data:
  - i'd want the value of each variable, and the value of the expression
  - - AAAAAAAAAAAAA THE FUNCTIONS AREN"T PURE
get something on the screen as soon as possible:
  - this autocomplete thing is mostly a question of function naming
  - - all this means is creating an alias layer around an existing library
    - "```javascript const betterNamedFunction = worse\\_named\\_function;"
    - "```python better\\_named\\_function = worse\\_named\\_function;"
  - are we trying to make art?
  - - i mean the way people talk about it
    - all this creativity talk 
    - i don't know what i'm talking about
  - before you can learn to `program' (verb), you must learn the `program' (noun). You feel me?
create by abstraction:
  - She \emph{doesn't}. The learner should start by writing concrete code, and then \emph{gradually \sout{change} refactor} it to introduce abstraction.
  - "The real power of programming comes when you have antifragile systems: ie, when you refactor properly."
  - - if you want people to feel in control of the systems they write---they can bend it to their will---the systems they create have to be antifragile
    - not really. but they have to at least not be fragile.
    - and the best way to teach that is that is to start with very small, stable pieces.
language:
  on languages:
    - smalltalk is a very good language
    - scheme/racket is also a very good language
    - learning scheme was a great idea for me but i don't think it's a good idea for people who aren't professional programmers; back to the `why are these people here' question.
    - i think that's the most important question we've got to ask.
    - parents need to understand their children probably won't become a 10x middle class software engineer haxx0r.
decomposition:
  - i think top down design is very useful from a project development perspective
  - bottom up is that looser, you feel it, more agile perspective
  - the best is not between, but both simultaneously. this is the perspective of the dao.
recomposition:
  - lol the issue is global state lololololol
  - i'm glad we can all agree that global state is shit
